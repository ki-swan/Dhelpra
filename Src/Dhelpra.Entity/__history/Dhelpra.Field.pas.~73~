unit Dhelpra.Field;

interface

uses
  Dhelpra.Entity.Interfaces, Data.DB, System.JSON;

type

TDhelpraField = class(TInterfacedObject, iDhelpraField)
private
  FName : String;
  FValue : Variant;
  FData_type : TFieldType;
public
  constructor Create; reintroduce;
  destructor Destroy; override;
  class function New : iDhelpraField;

  function name : String; overload;
  function name(aValue : String) : iDhelpraField; overload;
  function value : Variant; overload;
  function value(aValue : Variant) : iDhelpraField; overload;

  function data_type : TFieldType; overload;
  function data_type(AValue : TFieldType) : iDhelpraField; overload;

  procedure clear;

  function toJSON : TJSONPair;
  function fromJSON(aJSONObject : TJSONPair) : iDhelpraField;
end;

implementation

uses
  System.SysUtils, System.Variants;

{ TDhelpraField }

constructor TDhelpraField.Create;
begin
  clear;
end;

destructor TDhelpraField.Destroy;
begin

  inherited;
end;

class function TDhelpraField.New: iDhelpraField;
begin
  Result := TDhelpraField.Create;
end;

function TDhelpraField.name(aValue: String): iDhelpraField;
begin
  Result := Self;
  if aValue = EmptyStr then raise Exception.Create('name não foi preenchido em branco');
  FName := aValue;
end;

function TDhelpraField.name: String;
begin
  Result := FName;
end;

function TDhelpraField.data_type: TFieldType;
begin
  Result := FData_type;
end;

function TDhelpraField.data_type(AValue: TFieldType): iDhelpraField;
begin
  Result := Self;
  FData_type := AValue;
end;

function TDhelpraField.value: Variant;
begin
  Result := FValue;
end;

function TDhelpraField.value(aValue: Variant): iDhelpraField;
begin
  Result := Self;
  FValue := aValue;
end;

procedure TDhelpraField.clear;
begin
  FName := '';
  FValue := '';
  FData_type := TFieldType.ftUnknown;
end;

function TDhelpraField.fromJSON(aJSONObject: TJSONPair): iDhelpraField;
begin
  Result := Self;
  raise Exception.Create('Não implementado ainda');
end;

function TDhelpraField.toJSON: TJSONPair;
begin
  raise Exception.Create('Não implementado ainda');
  case FData_type of
    ftUnknown: raise Exception.Create('Tipo desconhecido');
    ftString: TJSONPair.Create(FName, VarToStr(FValue));
    ftSmallint: raise Exception.Create('Não implementado ainda');
    ftInteger: TJSONPair.Create(FName, Integer(FValue));
    ftWord: raise Exception.Create('Não implementado ainda');
    ftBoolean: TJSONPair.Create(FName, Boolean(FValue));
    ftFloat: raise Exception.Create('Não implementado ainda');
    ftCurrency: raise Exception.Create('Não implementado ainda');
    ftDate: raise Exception.Create('Não implementado ainda');
    ftTime: raise Exception.Create('Não implementado ainda');
    ftDateTime: raise Exception.Create('Não implementado ainda');
    ftBlob: raise Exception.Create('Não implementado ainda');
    ftWideString: raise Exception.Create('Não implementado ainda');
    ftLargeint: raise Exception.Create('Não implementado ainda');
    ftTimeStamp: raise Exception.Create('Não implementado ainda');
    ftLongWord: raise Exception.Create('Não implementado ainda');
    ftShortint: raise Exception.Create('Não implementado ainda');
    ftSingle: Result := TJSONPair.Create(FName, Single(FValue));
  end;

end;












end.
